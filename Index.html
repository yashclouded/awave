<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alberto - Audio Visualizer</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div class="ui-overlay">
            <div class="loading hidden" id="loading">
                <div class="spinner"></div>
                <div>Loading audio...</div>
            </div>
            <div class="controls">
                <label for="fileInput" class="file-label">Upload Music</label>
                <input type="file" id="fileInput" accept="audio/*">
                <button class="btn" id="playPauseBtn" disabled>▶ Play</button>
                <div class="volume-control">
                    <span>Volume</span>
                    <input type="range" class="volume-slider" id="volumeSlider" min="0" max="1" step="0.1" value="0.5">
                </div>
                <button class="btn test-btn" id="testBtn">🎵 Test</button>
            </div>
        </div>
        <div class="wave-container">
            <canvas id="waveCanvas"></canvas>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class AudioVisualizer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.analyser = null;
                this.audioContext = null;
                this.audio = null;
                this.dataArray = null;
                this.audioShapes = [];
                this.particles = [];
                this.isPlaying = false;
                this.mouseX = 0;
                this.mouseY = 0;
                this.waveCanvas = null;
                this.waveCtx = null;
                this.waveWidth = 0;
                this.waveHeight = 200;
                this.init();
                this.initWaveAnimation();
                this.setupEventListeners();
                this.animate();
            }

            init() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x0f0f23, 10, 100);

                // Camera setup
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 10, 30);
                this.camera.lookAt(0, 0, 0);

                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('canvas'),
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 1.0);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);

                const pointLight = new THREE.PointLight(0x6366f1, 1, 100);
                pointLight.position.set(0, 20, 10);
                pointLight.castShadow = true;
                this.scene.add(pointLight);

                const pointLight2 = new THREE.PointLight(0x8b5cf6, 0.8, 100);
                pointLight2.position.set(-20, 10, -10);
                this.scene.add(pointLight2);

                //initial shapes
                this.createMultipleShapes();
                this.createParticles();
                this.createBackground();
            }

            createMultipleShapes() {
                this.audioShapes = [];

                const tubePoints = [];
                for (let i = 0; i < 150; i++) { 
                    const t = (i / 150) * Math.PI * 6; 
                    tubePoints.push(new THREE.Vector3(
                        Math.cos(t) * 5,    
                        Math.sin(t) * 5,   
                        (i / 150) * 15 - 7.5
                    ));
                }
                
                const tubeCurve = new THREE.CatmullRomCurve3(tubePoints);
                const tubeGeometry = new THREE.TubeGeometry(tubeCurve, 150, 0.8, 8, false); 
                const tubeMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        audioData: { value: 0 },
                        bassLevel: { value: 0 }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float audioData;
                        uniform float bassLevel;
                        varying vec3 vPosition;
                        varying float vAudioIntensity;
                        
                        void main() {
                            vPosition = position;
                            vec3 pos = position;
                            
                            float pulse = 1.0 + audioData * 0.4;
                            pos *= pulse;
                            
                            float wave = sin(length(pos) * 0.8 + time * 3.0) * audioData * 0.3;
                            pos += normal * wave;
                            
                            vAudioIntensity = audioData;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        varying vec3 vPosition;
                        varying float vAudioIntensity;
                        
                        void main() {
                            vec3 deepBlue = vec3(0.1, 0.3, 0.9);     //blue
                            vec3 purple = vec3(0.6, 0.2, 0.9);       //Purple
                            vec3 hotPink = vec3(1.0, 0.3, 0.6);      // pink
                            vec3 cyan = vec3(0.2, 0.8, 1.0);         //Cyan
                            
                            float gradientPos = (vPosition.z + 7.5) / 15.0; // Normalize Z position
                            gradientPos = clamp(gradientPos, 0.0, 1.0);
                            
                            float beatShift = sin(time * 0.15 + vAudioIntensity * 0.8) * 0.5 + 0.5;
                            float audioShift = vAudioIntensity * 0.3;
                            
                            vec3 color;
                            if (gradientPos < 0.5) {
                                color = mix(deepBlue, purple, gradientPos * 2.0);
                            } else {
                                color = mix(purple, hotPink, (gradientPos - 0.5) * 2.0);
                            }
                            
                            color = mix(color, cyan, beatShift * 0.2);
                            color = mix(color, hotPink, audioShift * 0.3);
                            
                            color *= (0.85 + vAudioIntensity * 0.15);
                            
                            float alpha = 0.7 + sin(gradientPos * 3.14159) * 0.2; // Varies from 0.5 to 0.9
                            
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    side: THREE.FrontSide,
                    depthWrite: true 
                });

                const coolTube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                coolTube.position.set(-15, 5, 0);
                this.scene.add(coolTube);
                this.audioShapes.push(coolTube);

                const linePoints = 200;
                const lineGeometry = new THREE.BufferGeometry();
                const linePositions = new Float32Array(linePoints * 3);
                const lineColors = new Float32Array(linePoints * 3);
                
                for (let i = 0; i < linePoints; i++) {
                    const t = (i / linePoints) * Math.PI * 8; // Multiple spiral turns
                    linePositions[i * 3] = Math.cos(t) * 8;     // X
                    linePositions[i * 3 + 1] = Math.sin(t) * 8; // Y
                    linePositions[i * 3 + 2] = (i / linePoints) * 10 - 5; // Z progression
                    
                    lineColors[i * 3] = 1.0;     // R
                    lineColors[i * 3 + 1] = 0.5; // G
                    lineColors[i * 3 + 2] = 1.0; // B
                }
                
                lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
                lineGeometry.setAttribute('color', new THREE.BufferAttribute(lineColors, 3));
                
                const lineMaterial = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    linewidth: 5,
                    transparent: true,
                    opacity: 0.8
                });
                
                const audioLine = new THREE.Line(lineGeometry, lineMaterial);
                audioLine.position.set(15, 0, 0);
                this.scene.add(audioLine);
                this.audioShapes.push(audioLine);
            }

            createParticles() {
                const particleCount = 1000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);

                this.particleBaseColors = [];

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 100;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 100;

                    const hue = Math.random() * 360; // Full hue range
                    const saturation = 60 + Math.random() * 40; // 60-100% saturation
                    const lightness = 40 + Math.random() * 30; // 40-70% lightness

                    this.particleBaseColors.push({
                        h: hue,
                        s: saturation,
                        l: lightness
                    });

                    const color = new THREE.Color().setHSL(hue / 360, saturation / 100, lightness / 100);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 2.3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6
                });

                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
            }

            createBackground() {
                const geometry = new THREE.SphereGeometry(50, 32, 32);
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        audioLevel: { value: 0 },
                        bassLevel: { value: 0 },
                        trebleLevel: { value: 0 }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float bassLevel;
                        varying vec3 vPosition;
                        
                        void main() {
                            vPosition = position;
                            vec3 pos = position;
                            
                            pos *= 1.0 + bassLevel * 0.02;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float audioLevel;
                        uniform float bassLevel;
                        uniform float trebleLevel;
                        varying vec3 vPosition;
                        
                        void main() {
                            vec3 baseColor = vec3(0.0, 0.0, 0.0);
                            vec3 accentColor = vec3(0.05, 0.05, 0.1);
                            
                            float pattern = sin(vPosition.x * 0.01 + time * 0.2) * sin(vPosition.y * 0.008 + time * 0.15);
                            pattern *= audioLevel * 0.3;
                            
                            vec3 color = mix(baseColor, accentColor, pattern);
                            
                            color += bassLevel * 0.02;
                            
                            gl_FragColor = vec4(color, 1.0);
                        }
                    `,
                    side: THREE.BackSide
                });

                const backgroundMesh = new THREE.Mesh(geometry, material);
                this.scene.add(backgroundMesh);
            }

            updateParticleColors(audioLevel, bassLevel) {
                if (!this.particles || !this.particleBaseColors) return;

                const colors = this.particles.geometry.attributes.color.array;
                const particleCount = this.particleBaseColors.length;

                const globalIntensity = Math.pow(audioLevel, 0.8) * 0.7; 
                const bassIntensity = Math.pow(bassLevel, 1.2) * 0.5; 
                const combinedIntensity = Math.min(globalIntensity + bassIntensity, 1.0);

                for (let i = 0; i < particleCount; i++) {
                    const baseColor = this.particleBaseColors[i];
                    
                    let targetHue = baseColor.h;
                    let targetSaturation = Math.min(baseColor.s + combinedIntensity * 30, 100);
                    let targetLightness = Math.min(baseColor.l + combinedIntensity * 35, 85); 
                    
                    const glowHueShift = combinedIntensity * 15; 
                    if (baseColor.h > 180) {
                        targetHue = (baseColor.h - glowHueShift + 360) % 360; 
                    } else { 
                        targetHue = (baseColor.h + glowHueShift) % 360; 
                    }

                    const positions = this.particles.geometry.attributes.position.array;
                    const particleX = positions[i * 3];
                    const particleY = positions[i * 3 + 1];
                    const particleVariation = (Math.sin(particleX * 0.01) * Math.cos(particleY * 0.01) + 1) * 0.5;
                    const localIntensity = combinedIntensity * (0.7 + particleVariation * 0.6);

                    const currentHue = baseColor.h + (targetHue - baseColor.h) * localIntensity;
                    const currentSaturation = baseColor.s + (targetSaturation - baseColor.s) * localIntensity;
                    const currentLightness = baseColor.l + (targetLightness - baseColor.l) * localIntensity;

                    const color = new THREE.Color().setHSL(
                        currentHue / 360, 
                        currentSaturation / 100, 
                        currentLightness / 100
                    );

                    // Update color array
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }

                this.particles.geometry.attributes.color.needsUpdate = true;
            }

            initWaveAnimation() {
                this.waveCanvas = document.getElementById('waveCanvas');
                this.waveCtx = this.waveCanvas.getContext('2d');
                
                this.waveWidth = window.innerWidth;
                this.waveHeight = 200;
                this.waveCanvas.width = this.waveWidth;
                this.waveCanvas.height = this.waveHeight;                
                window.addEventListener('resize', () => {
                    this.waveWidth = window.innerWidth;
                    this.waveCanvas.width = this.waveWidth;
                });
            }

            drawEpicWaves(time, audioLevel, bassLevel, midLevel, trebleLevel) {
                const ctx = this.waveCtx;
                const width = this.waveWidth;
                const height = this.waveHeight;
                
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                const bassMultiplier = this.isPlaying ? Math.pow(bassLevel, 1.5) * 1.5 : 0.1;
                const amplitudeMultiplier = this.isPlaying ? Math.pow(audioLevel, 1.2) * 1.2 : 0.05;
                const energyBoost = this.isPlaying ? (bassLevel + audioLevel) * 0.2 : 0;
                
                const waves = [
                    {
                        amplitude: this.isPlaying ? (4 + bassLevel * 25 + energyBoost * 8) : 2,
                        frequency: this.isPlaying ? (0.015 + bassLevel * 0.005) : 0.02,
                        speed: this.isPlaying ? (time * (1.2 + bassMultiplier * 0.5)) : time * 0.3,
                        color: this.isPlaying ? `hsla(${300 + bassLevel * 60}, ${70 + bassLevel * 20}%, ${50 + bassLevel * 15}%, 0.7)` : 'hsla(320, 60%, 50%, 0.4)',
                        lineWidth: this.isPlaying ? (2 + bassLevel * 2) : 1.5,
                        phase: 0
                    },
                    {
                        amplitude: this.isPlaying ? (3 + midLevel * 20 + energyBoost * 6) : 1.5,
                        frequency: this.isPlaying ? (0.02 + midLevel * 0.004) : 0.025,
                        speed: this.isPlaying ? (time * (1.0 + amplitudeMultiplier * 0.5)) : time * 0.4,
                        color: this.isPlaying ? `hsla(${180 + midLevel * 80}, ${80 + midLevel * 15}%, ${40 + midLevel * 20}%, 0.6)` : 'hsla(210, 70%, 45%, 0.3)',
                        lineWidth: this.isPlaying ? (1.5 + midLevel * 1.5) : 1.2,
                        phase: Math.PI / 3
                    },
                    {
                        amplitude: this.isPlaying ? (2 + trebleLevel * 15 + energyBoost * 4) : 1,
                        frequency: this.isPlaying ? (0.025 + trebleLevel * 0.006) : 0.03,
                        speed: this.isPlaying ? (time * (1.5 + trebleLevel * 1)) : time * 0.6,
                        color: this.isPlaying ? `hsla(${60 + trebleLevel * 60}, ${90 + trebleLevel * 8}%, ${55 + trebleLevel * 15}%, 0.5)` : 'hsla(90, 75%, 60%, 0.25)',
                        lineWidth: this.isPlaying ? (1 + trebleLevel * 1.5) : 1,
                        phase: Math.PI / 2
                    },
                    {
                        amplitude: this.isPlaying ? (5 + audioLevel * 35 + bassLevel * 15) : 2,
                        frequency: this.isPlaying ? (0.012 + audioLevel * 0.004) : 0.015,
                        speed: this.isPlaying ? (time * (0.8 + amplitudeMultiplier * 0.3 + bassMultiplier * 0.3)) : time * 0.2,
                        color: this.isPlaying ? `hsla(${120 + audioLevel * 120}, ${75 + audioLevel * 15}%, ${45 + audioLevel * 20}%, 0.4)` : 'hsla(180, 60%, 40%, 0.2)',
                        lineWidth: this.isPlaying ? (2.5 + audioLevel * 2) : 1.8,
                        phase: Math.PI
                    },
                    {
                        amplitude: this.isPlaying ? (1.5 + bassLevel * 18 + energyBoost * 5) : 0.8,
                        frequency: this.isPlaying ? (0.035 + bassLevel * 0.008) : 0.04,
                        speed: this.isPlaying ? (time * (2 + bassMultiplier)) : time * 0.8,
                        color: this.isPlaying ? `hsla(${0 + bassLevel * 60}, 100%, ${60 + bassLevel * 15}%, 0.8)` : 'hsla(20, 80%, 60%, 0.15)',
                        lineWidth: this.isPlaying ? (1 + bassLevel * 1.2) : 0.8,
                        phase: Math.PI / 4
                    }
                ];
                
                waves.forEach((wave, index) => {
                    ctx.beginPath();
                    ctx.strokeStyle = wave.color;
                    ctx.lineWidth = wave.lineWidth;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';                    
                    ctx.shadowColor = wave.color;
                    ctx.shadowBlur = 15 + audioLevel * 20;
                    
                    let firstPoint = true;
                    
                    for (let x = 0; x <= width; x += 2) {
                        let y = height / 2;
                        
                        if (this.isPlaying) {
                            y += Math.sin(x * wave.frequency + wave.speed + wave.phase) * wave.amplitude;                            
                            const bassHarmonic = Math.sin(x * wave.frequency * 2 + wave.speed * 1.5 + wave.phase) * (wave.amplitude * 0.25 * (1 + bassLevel * 0.5));
                            y += bassHarmonic;                            
                            const energyHarmonic = Math.sin(x * wave.frequency * 4 + wave.speed * 2 + wave.phase) * (wave.amplitude * 0.1 * (1 + energyBoost * 0.5));
                            y += energyHarmonic;                            
                            const audioMod = Math.sin(x * 0.008 + time * (1.2 + amplitudeMultiplier * 0.3)) * audioLevel * 8;
                            y += audioMod;                            
                            const bassMod = Math.sin(x * 0.005 + time * (1.5 + bassMultiplier * 0.5)) * bassLevel * 10;
                            y += bassMod;
                            
                            if (index === 0) y += Math.sin(x * 0.006 + time * (1.8 + bassLevel)) * bassLevel * 8;
                            if (index === 1) y += Math.sin(x * 0.01 + time * (1.5 + midLevel)) * midLevel * 6;
                            if (index === 2) y += Math.sin(x * 0.014 + time * (2 + trebleLevel)) * trebleLevel * 5;
                            if (index === 3) y += Math.sin(x * 0.004 + time * (1.2 + audioLevel)) * audioLevel * 7;
                            
                        } else {
                            y += Math.sin(x * wave.frequency + wave.speed + wave.phase) * wave.amplitude;
                            
                            y += Math.sin(x * wave.frequency * 1.5 + wave.speed * 0.8 + wave.phase) * (wave.amplitude * 0.2);
                        }
                        
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.stroke();
                    ctx.shadowBlur = 0; // Reset shadow
                });
                
                if (this.isPlaying && (audioLevel > 0.4 || bassLevel > 0.5)) {
                    const particleCount = Math.floor((audioLevel * 8) + (bassLevel * 12));
                    
                    for (let i = 0; i < particleCount; i++) {
                        const x = Math.random() * width;
                        const baseY = height / 2;                        
                        const spread = (30 + bassLevel * 60 + audioLevel * 40);
                        const y = baseY + (Math.random() - 0.5) * spread;                        
                        const size = Math.random() * (1.5 + bassLevel * 2) + 0.3;
                        
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        
                        const hue = Math.random() * 360;
                        const saturation = 70 + bassLevel * 20;
                        const lightness = 50 + audioLevel * 20;
                        const alpha = 0.2 + bassLevel * 0.3 + audioLevel * 0.2;
                        
                        ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                        ctx.fill();
                        
                        if (bassLevel > 0.7) {
                            ctx.shadowColor = ctx.fillStyle;
                            ctx.shadowBlur = 4 + bassLevel * 6;
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    }
                }
            }

            async setupAudio(file) {
                try {
                    document.getElementById('loading').classList.remove('hidden');

                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    
                    const bufferLength = this.analyser.frequencyBinCount;
                    this.dataArray = new Uint8Array(bufferLength);

                    if (this.audio) {
                        this.audio.pause();
                    }

                    this.audio = new Audio();
                    this.audio.src = URL.createObjectURL(file);
                    
                    const source = this.audioContext.createMediaElementSource(this.audio);
                    source.connect(this.analyser);
                    this.analyser.connect(this.audioContext.destination);

                    await new Promise((resolve, reject) => {
                        this.audio.addEventListener('canplaythrough', resolve);
                        this.audio.addEventListener('error', reject);
                        this.audio.load();
                    });

                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('playPauseBtn').disabled = false;
                    
                } catch (error) {
                    console.error('Error setting up audio:', error);
                    document.getElementById('loading').classList.add('hidden');
                    alert('Error loading audio file. Please try a different file.');
                }
            }

            togglePlayPause() {
                if (!this.audio) return;

                if (this.isPlaying) {
                    this.audio.pause();
                    this.isPlaying = false;
                    document.getElementById('playPauseBtn').textContent = '▶️ Play';
                } else {
                    this.audio.play();
                    this.isPlaying = true;
                    document.getElementById('playPauseBtn').textContent = '⏸️ Pause';
                }
            }

            setVolume(volume) {
                if (this.audio) {
                    this.audio.volume = volume;
                }
            }

            async loadTestAudio() {
                try {
                    document.getElementById('loading').classList.remove('hidden');

                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    
                    const bufferLength = this.analyser.frequencyBinCount;
                    this.dataArray = new Uint8Array(bufferLength);

                    if (this.audio) {
                        this.audio.pause();
                    }

                    this.audio = new Audio();
                    this.audio.src = './resource/badguy.mp3'; 
                    
                    const source = this.audioContext.createMediaElementSource(this.audio);
                    source.connect(this.analyser);
                    this.analyser.connect(this.audioContext.destination);

                    await new Promise((resolve, reject) => {
                        this.audio.addEventListener('canplaythrough', resolve);
                        this.audio.addEventListener('error', reject);
                        this.audio.load();
                    });

                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('playPauseBtn').disabled = false;                    
                    // test audio
                    this.audio.play();
                    this.isPlaying = true;
                    document.getElementById('playPauseBtn').textContent = '⏸️ Pause';
                    
                } catch (error) {
                    console.error('Error loading test audio:', error);
                    document.getElementById('loading').classList.add('hidden');
                    alert('Error loading test audio. Make sure badguy.mp3 exists in the resource folder.');
                }
            }

            setupEventListeners() {
                this.mouseX = 0;
                this.mouseY = 0;

                document.getElementById('fileInput').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.setupAudio(file);
                    }
                });

                document.getElementById('playPauseBtn').addEventListener('click', () => {
                    this.togglePlayPause();
                });

                document.getElementById('volumeSlider').addEventListener('input', (e) => {
                    this.setVolume(e.target.value);
                });

                document.getElementById('testBtn').addEventListener('click', () => {
                    this.loadTestAudio();
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                // Mouse interaction
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const time = Date.now() * 0.001;

                // Initialize audio data variables
                let audioLevel = 0, bassLevel = 0, midLevel = 0, trebleLevel = 0;

                if (this.analyser && this.isPlaying) {
                    this.analyser.getByteFrequencyData(this.dataArray);
                    const bufferLength = this.dataArray.length;
                    const bassEnd = Math.floor(bufferLength * 0.15);
                    const midEnd = Math.floor(bufferLength * 0.6);                    
                    let bassSum = 0, midSum = 0, trebleSum = 0, totalSum = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        totalSum += this.dataArray[i];
                        if (i < bassEnd) bassSum += this.dataArray[i];
                        else if (i < midEnd) midSum += this.dataArray[i];
                        else trebleSum += this.dataArray[i];
                    }
                    
                    bassLevel = Math.min(bassSum / bassEnd / 255, 1.0);
                    midLevel = Math.min(midSum / (midEnd - bassEnd) / 255, 1.0);
                    trebleLevel = Math.min(trebleSum / (bufferLength - midEnd) / 255, 1.0);
                    audioLevel = Math.min(totalSum / bufferLength / 255, 1.0);
                }

                this.audioShapes.forEach((shape, index) => {
                    if (shape.material.uniforms) {
                        const minShaderSpeed = 0.1; 
                        const maxShaderSpeedMultiplier = 2; 
                        const shaderTimeMultiplier = minShaderSpeed + (audioLevel * maxShaderSpeedMultiplier);
                        
                        shape.material.uniforms.time.value = time * shaderTimeMultiplier;
                        shape.material.uniforms.audioData.value = audioLevel;
                        
                        if (shape.material.uniforms.bassLevel) {
                            shape.material.uniforms.bassLevel.value = bassLevel;
                        }
                        if (shape.material.uniforms.midLevel) {
                            shape.material.uniforms.midLevel.value = midLevel;
                        }
                        if (shape.material.uniforms.trebleLevel) {
                            shape.material.uniforms.trebleLevel.value = trebleLevel;
                        }
                    }
                    
                    if (this.isPlaying) {
                        const speedBase = 0.1 + audioLevel * 2;
                        const bassSpeed = 0.1 + bassLevel * 2;

                        switch(index) {
                            case 0: // Cool Tube
                                shape.rotation.x += (0.004 + audioLevel * 0.012) * speedBase;
                                shape.rotation.y += (0.007 + bassLevel * 0.015) * bassSpeed;
                                shape.rotation.z += (0.002 + midLevel * 0.008) * speedBase;
                                
                                const tubeScale = 1 + audioLevel * 0.2 + bassLevel * 0.3;
                                shape.scale.set(tubeScale, tubeScale, tubeScale);
                                break;
                            case 1:
                                if (shape.geometry && shape.geometry.attributes.position) {
                                    const positions = shape.geometry.attributes.position.array;
                                    const colors = shape.geometry.attributes.color.array;
                                    const linePoints = positions.length / 3;
                                    
                                    for (let i = 0; i < linePoints; i++) {
                                        const t = (i / linePoints) * Math.PI * 8;
                                        const timeOffset = time * speedBase;                                        
                                        const radius = 8 + Math.sin(t * 2 + timeOffset) * audioLevel * 4;
                                        const heightVariation = Math.sin(t * 3 + timeOffset * 1.5) * bassLevel * 3;
                                        const tanglingFactor = Math.cos(t * 5 + timeOffset * 2) * midLevel * 2;
                                        
                                        const trebleTangle = Math.sin(t * 8 + timeOffset * 3) * trebleLevel * 1.5;
                                        
                                        positions[i * 3] = Math.cos(t + tanglingFactor) * radius + trebleTangle;
                                        positions[i * 3 + 1] = Math.sin(t + tanglingFactor) * radius + heightVariation;
                                        positions[i * 3 + 2] = (i / linePoints) * 10 - 5 + Math.sin(t + timeOffset) * audioLevel * 2;
                                        
                                        const intensity = audioLevel + (i / linePoints) * 0.5;
                                        colors[i * 3] = 0.5 + bassLevel * 0.5 + Math.sin(timeOffset + i * 0.1) * 0.3;     // R
                                        colors[i * 3 + 1] = 0.3 + midLevel * 0.7 + Math.cos(timeOffset + i * 0.1) * 0.3;  // G
                                        colors[i * 3 + 2] = 0.8 + trebleLevel * 0.2 + Math.sin(timeOffset * 2 + i * 0.1) * 0.2; // B
                                    }
                                    
                                    shape.geometry.attributes.position.needsUpdate = true;
                                    shape.geometry.attributes.color.needsUpdate = true;
                                }

                                // Gentle rotation of the entire line in 3D space
                                shape.rotation.x += (0.001 + audioLevel * 0.003) * speedBase;
                                shape.rotation.y += (0.002 + bassLevel * 0.004) * bassSpeed;
                                break;
                        }
                    }
                });

                if (this.particles) {
                    // Update particle colors based on audio
                    this.updateParticleColors(audioLevel, bassLevel);

                    if (this.isPlaying) {
                        const particleSpeed = 0.2 + audioLevel * 3;
                        
                        this.particles.rotation.x += (0.001 + bassLevel * 0.006) * (0.2 + bassLevel * 2);
                        this.particles.rotation.y += (0.002 + midLevel * 0.005) * (0.2 + midLevel * 2);
                        this.particles.rotation.z += (0.0005 + trebleLevel * 0.004) * (0.2 + trebleLevel * 1.5);
                        
                        const positions = this.particles.geometry.attributes.position.array;
                        for (let i = 0; i < positions.length; i += 3) {
                            const moveIntensity = 0.01 * particleSpeed; 
                            const timeSpeed = particleSpeed * 0.3; 
                            
                            positions[i] += Math.sin(time * timeSpeed + positions[i] * 0.01) * moveIntensity * trebleLevel;
                            positions[i + 1] += Math.sin(time * (timeSpeed * 0.6) + positions[i] * 0.01) * moveIntensity * audioLevel;
                            positions[i + 2] += Math.cos(time * (timeSpeed * 0.8) + positions[i] * 0.01) * moveIntensity * midLevel;
                        }
                        this.particles.geometry.attributes.position.needsUpdate = true;
                    }
                    
                    const targetScale = 1 + audioLevel * 0.3;
                    this.particles.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);                    
                    const targetOpacity = 0.6 + audioLevel * 0.3;
                    this.particles.material.opacity += (targetOpacity - this.particles.material.opacity) * 0.1;
                }

                this.scene.children.forEach(child => {
                    if (child.type === 'PointLight') {
                        if (child.position.y > 15) { // Main light
                            const targetIntensity = 1 + audioLevel * 0.8;
                            child.intensity += (targetIntensity - child.intensity) * 0.1;
                            
                            const hue = 0.7 + bassLevel * 0.2;
                            const saturation = 0.8 + midLevel * 0.2;
                            const lightness = 0.5 + audioLevel * 0.2;
                            child.color.setHSL(hue, saturation, lightness);
                        } else { // Secondary light
                            const targetIntensity = 0.8 + trebleLevel * 0.6;
                            child.intensity += (targetIntensity - child.intensity) * 0.1;
                            
                            const hue = 0.8 + trebleLevel * 0.15;
                            const saturation = 0.9;
                            const lightness = 0.5 + audioLevel * 0.15;
                            child.color.setHSL(hue, saturation, lightness);
                        }
                    }
                });

                this.scene.children.forEach(child => {
                    if (child.material && child.material.uniforms && child.material.uniforms.time) {
                        if (this.isPlaying) {
                            const bgSpeed = 0.4 + audioLevel * 2.5;
                            child.material.uniforms.time.value = time * bgSpeed + audioLevel * 2;
                        }
                        
                        if (!child.material.uniforms.audioLevel) {
                            child.material.uniforms.audioLevel = { value: 0 };
                            child.material.uniforms.bassLevel = { value: 0 };
                            child.material.uniforms.trebleLevel = { value: 0 };
                        }
                        child.material.uniforms.audioLevel.value = audioLevel;
                        child.material.uniforms.bassLevel.value = bassLevel;
                        child.material.uniforms.trebleLevel.value = trebleLevel;
                    }
                });

                // Camera movement
                const baseX = this.mouseX * 3;
                const baseY = this.mouseY * 3 + 10;
                const baseZ = 30;
                
                let targetX = baseX;
                let targetY = baseY;
                let targetZ = baseZ;
                
                if (this.isPlaying) {
                    const cameraSpeed = 0.6 + audioLevel * 2;
                    const cameraFloat = Math.sin(time * (0.3 * cameraSpeed)) * audioLevel * 0.4;
                    targetX = baseX + cameraFloat;
                    targetY = baseY + Math.cos(time * (0.2 * cameraSpeed)) * audioLevel * 0.3;
                    targetZ = baseZ + bassLevel * 2;
                }
                
                
                this.camera.position.x += (targetX - this.camera.position.x) * 0.03;
                this.camera.position.y += (targetY - this.camera.position.y) * 0.03;
                this.camera.position.z += (targetZ - this.camera.position.z) * 0.05;
                
                let targetFOV = this.isPlaying ? 75 + bassLevel * 12 + audioLevel * 5 : 75;
                this.camera.fov += (targetFOV - this.camera.fov) * 0.1;
                this.camera.updateProjectionMatrix();
                
                this.camera.lookAt(0, 0, 0);

                // Render epic bottom wave animation
                if (this.waveCtx) {
                    this.drawEpicWaves(time, audioLevel, bassLevel, midLevel, trebleLevel);
                }

                this.renderer.render(this.scene, this.camera);
            }
        }
        // Initialize the visualizer
        const visualizer = new AudioVisualizer();
    </script>
</body>
</html>